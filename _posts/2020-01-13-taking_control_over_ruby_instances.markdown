---
layout: post
title:      "Taking Control Over Ruby Instances"
date:       2020-01-13 20:49:49 +0000
permalink:  taking_control_over_ruby_instances
---


During the brief time I have been in pursuit of my coding career with Flatiron’s Software Engineering school, there have been times where learning the Ruby language presented some rather abstract concepts. At the top of this list of abstractions, has been learning the concept of instances, instance variables and the initialize method, the getter-setter methods and how these things work together.

To start with, I thought it would be wise to revisit the Flatiron instance method section. Here we have a class Dog, with a method called bark. Anytime the .new method is called on the Dog class, a new instance of a dog is created. Oh, and by the way, the .new method is actually a class method, which allows us to call on new instances of a class from outside the class, which is pretty cool when you start realizing how important scope is in Ruby. Within the Dog class the bark method applies to all new instances of dogs, therefore all dogs created within this class will be able to bark. So, that section really shows a great example of instantiating a new class object. But, no where in this example are there any instance variables. 

So now, I move on to look at what instance variables are all about. I have seen that a new class instance can be created without using instance variables, so, what are instance variables for? As it turns out, instance variables are designed to help not to confuse. So, if we have a Dog class that is taking in the argument of a name. The instance variable gets assigned that name, when the .new instance of the Dog class is invoked. Where the instance variable comes handy is when we have other methods that will require the use of that instance variable. A great example of such methods would be the getter-setter methods. 

The getter-setter method can be very confusing at first until you understand what it is you are getting and setting. Usually the getter setter method is obtaining an attribute of the class, therefore it is a class method. So, in the Dog class example provided by Flatiron, the method “def name=(dogs_name)”, is taking in an argument of the dogs name and setting that attribute to whatever the name happens to be. Therefore, setter methods will start with the method name and have an equal sign next to it. While the “def name” method is getting the name so that it can be used for other purposes, such as printing out the dog’s name, or storing the dog’s name in a database. Both of these methods use the @this_dogs_name instance variable. Using the @ symbol is what actually identifies instance variables. So, when the .new method is invoked, both the getter and setter work in conjunction with the new instance being created.

If you thought that was cool, it gets even better. Ruby has simplified the getter-setter methods in three different ways. First, if one requires both a getter and a setter method, then using the attr_accessor method is all of that rolled up into one method. It simplifies the code and eliminates lots of extra code. If you just need a reader method, a.k.a “getter method ruby simplifies the code with the attr_reader method. Or perhaps you need just a writer method, aka “setter method”. Ruby provides the attr_writer method which simplifies the code as well.

In all these examples up to this point, there has been no example of using the initialize method. How does the initialize method work with instance variables and what is it actually used for? This was definitely another confusing abstract concept for me. Because, we are writing code that invokes new instances of a class, which incorporates  reading and writing attributes of that class with instance variables. The code works fine, so why would we want to mess things up with an initialize method? Well, as it turns out, the initialize method’s purpose is to simplify the code even more. 
Remember when we called the .new method to create a new instance of the Dog class? When the .new method is invoked, the initialize method is triggered which allows you to create new objects with arguments. In some cases, lots of arguments. In most cases arguments are attributes, like in our Dog class, name and breed are arguments, they will most likely change when a new instance of the Dog class is created, because each dog will probably have a different name, and a different breed. Many other arguments can be passed into the instance variables, such as the dog’s owner name, the dog’s location, his favorite toy, etc. When a new argument is passed into the initialize method, the initialize method assigns the arguments to the appropriate instance variable.  Another really great thing about the initialize method is that you can define optional and default arguments. 

What if you have a class that will take in arguments that change from time to time. I found a great example of how to dynamically change arguments passed into the initialize method in Flatiron’s “Mass Assignment and Metaprogramming” section. In the example, the initialize method takes in unspecified key-value pairs from hashes, and it iterates over each key/value pair. The name of the key becomes the name of the setter method, while the value of the key is then passed to that method. The self.send method calls the key name, with an argument of the key’s value. In other words, the key-value pair that is passed defines the new instance attributes of that class. I actually incorporated this method in my CLI Scraper Project, and it worked like a charm.

One last thing to note, is that in my learning process, it has helped me to draw diagrams, write about the different topics that have been confusing to me, watch videos and continuously look up different examples. As a former teacher, I know that people are different, and learn differently. So, if something is confusing you or seems extremely abstract, incorporate different learning methods that work best for you. One thing I know is certain, once you have learned a concept that was once confusing, try teaching it to your cohort, or some other student. The theory is, if you can teach on a particular subject well enough that other people can understand, then you definitely have a grasp on the concepts you have been learning. 

